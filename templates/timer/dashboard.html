{% extends 'base.html' %}

{% block title %}Dashboard - EyeHealth 20-20-20{% endblock %}

{% block extra_css %}
<style>
    .timer-container {
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
        border-radius: 1rem;
        color: white;
        padding: 2rem;
        margin-bottom: 2rem;
    }

    .dashboard-timer-circle {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 3px solid rgba(255, 255, 255, 0.2);
    }
    
    .session-card {
        transition: transform 0.2s ease-in-out;
    }
    
    .session-card:hover {
        transform: translateY(-2px);
    }
    
    .progress-ring {
        transform: rotate(-90deg);
    }
    
    .progress-ring-circle {
        transition: stroke-dasharray 0.3s ease-in-out;
        fill: transparent;
        stroke: #ffc107;
        stroke-width: 4;
        stroke-linecap: round;
    }
    
    /* Emergency fixes for modal issues */
    .modal.show {
        display: block !important;
    }
    
    .modal-backdrop {
        z-index: 1040;
    }
    
    .modal {
        z-index: 1050;
    }
    
    /* Force close button styling */
    .btn-outline-danger.btn-sm {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        margin-left: auto;
    }
    
    /* Notification improvements */
    .notification {
        z-index: 10000 !important;
    }
    
    /* Sound notification animations */
    .sound-notification {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    @keyframes soundPulse {
        0% { 
            transform: translateX(-50%) scale(0.8);
            opacity: 0;
        }
        10% {
            transform: translateX(-50%) scale(1.1);
            opacity: 1;
        }
        20% {
            transform: translateX(-50%) scale(0.95);
        }
        30% {
            transform: translateX(-50%) scale(1.05);
        }
        40% {
            transform: translateX(-50%) scale(0.98);
        }
        100% {
            transform: translateX(-50%) scale(1);
            opacity: 1;
        }
    }
    
    @keyframes fadeOut {
        from {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }
        to {
            opacity: 0;
            transform: translateX(-50%) scale(0.8);
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <!-- Welcome Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h1 class="h2 mb-1">Welcome back, {{ user.first_name|default:user.username }}!</h1>
                    <p class="text-muted mb-0">
                        <i class="fas fa-calendar-day me-1"></i>
                        Today is {% now "l, F j, Y" %}
                    </p>
                </div>
                {% if not user.is_premium_user %}
                    <a href="{% url 'accounts:pricing' %}" class="btn btn-warning">
                        <i class="fas fa-crown me-2"></i>Upgrade to Premium
                    </a>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Timer Section -->
    <div class="row">
        <div class="col-lg-8 mx-auto">
            <div class="timer-container text-center">
                {% if active_session %}
                    <h3 class="mb-3">
                        <i class="fas fa-play-circle me-2"></i>Session Active
                        <span class="badge bg-success ms-2">Interval {{ active_session.total_intervals_completed|add:1 }}</span>
                    </h3>
                {% else %}
                    <h3 class="mb-3">
                        <i class="fas fa-pause-circle me-2"></i>Ready to Start
                    </h3>
                {% endif %}
                
                <div class="timer-circle dashboard-timer-circle d-flex flex-column justify-content-center align-items-center">
                    <svg class="progress-ring" width="100%" height="100%">
                        <circle class="progress-ring-circle" 
                                cx="50%" cy="50%" r="110" 
                                stroke-dasharray="0 691.15" id="progress-circle"></circle>
                    </svg>
                    <div class="position-absolute">
                        <div class="timer-display" id="timer-display">
                            {% if active_session %}20:00{% else %}Ready{% endif %}
                        </div>
                        <div class="mt-2">
                            <small>{% if active_session %}Next Break In{% else %}Click Start{% endif %}</small>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4">
                    {% if active_session %}
                        <button class="btn btn-danger btn-lg me-3" onclick="endSession()">
                            <i class="fas fa-stop me-2"></i>End Session
                        </button>
                        <button class="btn btn-outline-light btn-lg" onclick="takeBreak()">
                            <i class="fas fa-coffee me-2"></i>Take Break Now
                        </button>
                    {% else %}
                        {% if can_start_session %}
                            <button class="btn btn-success btn-lg" onclick="startSession()">
                                <i class="fas fa-play me-2"></i>Start 20-20-20 Timer
                            </button>
                        {% else %}
                            <div class="alert alert-warning mt-3">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                You've reached your daily limit of {{ daily_limit }} sessions. 
                                <a href="{% url 'accounts:pricing' %}" class="alert-link">Upgrade to Pro</a> for unlimited sessions.
                            </div>
                        {% endif %}
                    {% endif %}
                </div>
                
                {% if active_session %}
                    <div class="mt-3">
                        <small>
                            Session started: {{ active_session.start_time|time:"g:i A" }} | 
                            Intervals completed: {{ active_session.total_intervals_completed }} | 
                            Breaks taken: {{ active_session.total_breaks_taken }}
                        </small>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Today's Statistics -->
    <div class="row mb-4">
        <div class="col-12">
            <h4 class="mb-3">
                <i class="fas fa-chart-line me-2"></i>Today's Progress
            </h4>
        </div>
        <div class="col-lg-3 col-md-6 mb-3">
            <div class="card session-card h-100">
                <div class="card-body text-center">
                    <div class="text-primary mb-2">
                        <i class="fas fa-clock fa-2x"></i>
                    </div>
                    <h3 class="mb-1">{{ today_stats.total_work_minutes|default:0 }}</h3>
                    <p class="text-muted mb-0">Minutes Worked</p>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-6 mb-3">
            <div class="card session-card h-100">
                <div class="card-body text-center">
                    <div class="text-success mb-2">
                        <i class="fas fa-tasks fa-2x"></i>
                    </div>
                    <h3 class="mb-1">{{ today_stats.total_intervals_completed|default:0 }}</h3>
                    <p class="text-muted mb-0">Intervals Completed</p>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-6 mb-3">
            <div class="card session-card h-100">
                <div class="card-body text-center">
                    <div class="text-warning mb-2">
                        <i class="fas fa-coffee fa-2x"></i>
                    </div>
                    <h3 class="mb-1">{{ today_stats.total_breaks_taken|default:0 }}</h3>
                    <p class="text-muted mb-0">Breaks Taken</p>
                </div>
            </div>
        </div>
        <div class="col-lg-3 col-md-6 mb-3">
            <div class="card session-card h-100">
                <div class="card-body text-center">
                    <div class="text-info mb-2">
                        <i class="fas fa-percentage fa-2x"></i>
                    </div>
                    <h3 class="mb-1">{{ today_stats.compliance_rate|floatformat:0|default:0 }}%</h3>
                    <p class="text-muted mb-0">Compliance Rate</p>
                </div>
            </div>
        </div>
    </div>

    <!-- How It Works Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-info-circle me-2"></i>How the 20-20-20 Rule Works
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <div class="d-flex align-items-start">
                                <div class="bg-primary text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px;">
                                    <span class="fw-bold">20</span>
                                </div>
                                <div>
                                    <h6 class="mb-1">Every 20 Minutes</h6>
                                    <small class="text-muted">Work in focused 20-minute intervals. The timer will automatically remind you when it's time for a break.</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <div class="d-flex align-items-start">
                                <div class="bg-success text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px;">
                                    <span class="fw-bold">20</span>
                                </div>
                                <div>
                                    <h6 class="mb-1">Look 20 Feet Away</h6>
                                    <small class="text-muted">During breaks, look at something at least 20 feet away to relax your eye muscles and reduce strain.</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <div class="d-flex align-items-start">
                                <div class="bg-warning text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px;">
                                    <span class="fw-bold">20</span>
                                </div>
                                <div>
                                    <h6 class="mb-1">For 20 Seconds</h6>
                                    <small class="text-muted">Hold your gaze on the distant object for at least 20 seconds. This gives your eyes time to reset and refocus.</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="row">
                        <div class="col-md-6">
                            <h6><i class="fas fa-tasks me-2 text-primary"></i>Intervals Explained</h6>
                            <p class="small text-muted mb-0">Each work session consists of multiple 20-minute intervals. Complete intervals help track your productivity and compliance with the 20-20-20 rule.</p>
                        </div>
                        <div class="col-md-6">
                            <h6><i class="fas fa-coffee me-2 text-success"></i>Break Benefits</h6>
                            <p class="small text-muted mb-0">Regular breaks prevent digital eye strain, reduce fatigue, and improve focus. Compliant breaks (looking at distance) are most effective.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Recent Sessions -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="fas fa-history me-2"></i>Recent Sessions
                    </h5>
                    <a href="{% url 'timer:statistics' %}" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-chart-bar me-1"></i>View All Statistics
                    </a>
                </div>
                <div class="card-body">
                    {% if recent_sessions %}
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Start Time</th>
                                        <th>Duration</th>
                                        <th>Intervals</th>
                                        <th>Breaks</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for session in recent_sessions %}
                                    <tr>
                                        <td>{{ session.start_time|date:"M j" }}</td>
                                        <td>{{ session.start_time|time:"g:i A" }}</td>
                                        <td>{{ session.duration_minutes }} min</td>
                                        <td>
                                            <span class="badge bg-primary">{{ session.total_intervals_completed }}</span>
                                        </td>
                                        <td>
                                            <span class="badge bg-success">{{ session.total_breaks_taken }}</span>
                                        </td>
                                        <td>
                                            {% if session.is_active %}
                                                <span class="badge bg-warning">Active</span>
                                            {% else %}
                                                <span class="badge bg-secondary">Completed</span>
                                            {% endif %}
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    {% else %}
                        <div class="text-center py-4">
                            <i class="fas fa-clock fa-3x text-muted mb-3"></i>
                            <h5>No sessions yet</h5>
                            <p class="text-muted">Start your first 20-20-20 timer session to begin tracking your eye health progress.</p>
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Break Reminder Modal -->
<div class="modal fade" id="breakModal" tabindex="-1" aria-labelledby="breakModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning text-dark">
                <h5 class="modal-title" id="breakModalLabel">
                    <i class="fas fa-eye me-2"></i>Time for a Break!
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <div class="mb-4">
                    <i class="fas fa-eye fa-4x text-warning mb-3"></i>
                    <h4>Follow the 20-20-20 Rule</h4>
                    <p class="lead">Look at something <strong>20 feet away</strong> for <strong>20 seconds</strong></p>
                </div>
                
                <div class="break-timer mb-4">
                    <div class="display-4 text-primary" id="break-countdown">20</div>
                    <p>seconds remaining</p>
                </div>
                
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="looked-distance">
                    <label class="form-check-label" for="looked-distance">
                        I looked at something 20 feet away
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="skipBreak()">
                    <i class="fas fa-forward me-2"></i>Skip Break
                </button>
                <button type="button" class="btn btn-success" onclick="completeBreak()">
                    <i class="fas fa-check me-2"></i>Break Complete
                </button>
                <button type="button" class="btn btn-outline-danger btn-sm" onclick="forceCloseModal('user_initiated')" title="Close if modal is stuck">
                    <i class="fas fa-times me-1"></i>Force Close
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let timerInterval;
    let currentSession = {% if active_session %}{{ active_session.id }}{% else %}null{% endif %};
    let currentInterval = {% if active_interval %}{{ active_interval.id }}{% else %}null{% endif %};
    let currentBreak = null;
    let timeRemaining = 1200; // 20 minutes in seconds
    let breakModalTimeout = null;
    let modalAutoCloseTimeout = null;
    let isModalStuck = false;

    function startSession() {
        fetch('{% url "timer:start_session" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentSession = data.session_id;
                currentInterval = data.interval_id;
                startTimer();
                location.reload();
            } else {
                alert(data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function endSession() {
        if (!currentSession) return;
        
        fetch('{% url "timer:end_session" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                stopTimer();
                location.reload();
            } else {
                alert(data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function takeBreak() {
        if (!currentSession || !currentInterval) return;
        
        fetch('{% url "timer:take_break" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                session_id: currentSession,
                interval_id: currentInterval,
                looked_at_distance: false
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                currentBreak = data.break_id;
                showBreakModal();
            } else {
                alert(data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function completeBreak() {
        if (!currentBreak) {
            console.warn('No current break to complete, closing modal');
            hideBreakModal();
            return;
        }
        
        const lookedAtDistance = document.getElementById('looked-distance')?.checked || false;
        
        // Add timeout to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
        
        fetch('{% url "timer:complete_break" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                break_id: currentBreak,
                looked_at_distance: lookedAtDistance
            }),
            signal: controller.signal
        })
        .then(response => {
            clearTimeout(timeoutId);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                currentBreak = null;
                currentInterval = data.next_interval_id;
                hideBreakModal();
                
                // Only reset timer if we have a next interval
                if (currentInterval) {
                    resetTimer();
                }
                
                if (data.is_compliant) {
                    showNotification('Great job! You followed the 20-20-20 rule correctly.', 'success');
                } else {
                    showNotification('Break completed. Remember to look at distant objects next time!', 'info');
                }
            } else {
                console.error('Break completion failed:', data.message);
                showNotification('Break completion failed: ' + (data.message || 'Unknown error'), 'error');
                // Still close modal to prevent getting stuck
                hideBreakModal();
            }
        })
        .catch(error => {
            clearTimeout(timeoutId);
            console.error('Error completing break:', error);
            
            if (error.name === 'AbortError') {
                showNotification('Break completion timed out. Closing modal...', 'warning');
            } else {
                showNotification('Network error completing break. Closing modal...', 'error');
            }
            
            // Always close modal to prevent getting stuck
            currentBreak = null;
            hideBreakModal();
            
            // Resume timer
            if (currentSession) {
                resetTimer();
            }
        });
    }

    function skipBreak() {
        try {
            // Clear current break if exists
            currentBreak = null;
            
            hideBreakModal();
            showNotification('Break skipped. Remember that regular breaks help protect your vision!', 'warning');
            
            // Resume timer if session is active
            if (currentSession) {
                resetTimer();
            }
        } catch (error) {
            console.error('Error skipping break:', error);
            forceCloseModal('skip_error');
        }
    }

    function startTimer() {
        timeRemaining = 1200; // 20 minutes
        updateTimerDisplay();
        updateProgressRing();
        
        timerInterval = setInterval(() => {
            timeRemaining--;
            updateTimerDisplay();
            updateProgressRing();
            
            if (timeRemaining <= 0) {
                onTimerComplete();
            }
        }, 1000);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    function resetTimer() {
        stopTimer();
        timeRemaining = 1200; // Reset to 20 minutes
        startTimer();
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        const timerDisplay = document.getElementById('timer-display');
        if (timerDisplay) {
            timerDisplay.textContent = display;
        }
    }

    function updateProgressRing() {
        const circle = document.getElementById('progress-circle');
        if (circle) {
            const totalTime = 1200; // 20 minutes
            const progress = ((totalTime - timeRemaining) / totalTime) * 691.15; // 2πr where r=110
            circle.setAttribute('stroke-dasharray', `${progress} ${691.15 - progress}`);
        }
    }

    function onTimerComplete() {
        stopTimer();
        showBreakModal();
        
        // Play enhanced notification sound if enabled
        {% if settings.sound_notification %}
            // Small delay to ensure modal is visible before sound
            setTimeout(() => {
                playNotificationSound();
            }, 100);
        {% endif %}
        
        // Show browser notification if enabled
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Time for a break!', {
                body: 'Look at something 20 feet away for 20 seconds.',
                icon: '/static/images/eye-icon.png'
            });
        }
        
        // Automatically take break
        takeBreak();
    }

    function showBreakModal() {
        try {
            // Clear any existing timeouts
            clearModalTimeouts();
            
            const modalElement = document.getElementById('breakModal');
            if (!modalElement) {
                console.error('Break modal element not found');
                handleModalError();
                return;
            }
            
            const modal = new bootstrap.Modal(modalElement, {
                backdrop: 'static',
                keyboard: true
            });
            
            // Add error handling for modal events
            modalElement.addEventListener('shown.bs.modal', onModalShown, { once: true });
            modalElement.addEventListener('hidden.bs.modal', onModalHidden, { once: true });
            
            modal.show();
            startBreakCountdown();
            
            // Set auto-close timeout (5 minutes maximum)
            modalAutoCloseTimeout = setTimeout(() => {
                console.warn('Modal auto-closing due to timeout');
                forceCloseModal('timeout');
            }, 300000); // 5 minutes
            
            // Track modal state
            isModalStuck = false;
            
        } catch (error) {
            console.error('Error showing break modal:', error);
            handleModalError();
        }
    }

    function hideBreakModal() {
        try {
            clearModalTimeouts();
            const modalElement = document.getElementById('breakModal');
            if (!modalElement) {
                console.warn('Modal element not found during hide');
                return;
            }
            
            const modal = bootstrap.Modal.getInstance(modalElement);
            if (modal) {
                modal.hide();
            } else {
                // Fallback: manually hide modal
                modalElement.style.display = 'none';
                modalElement.classList.remove('show');
                document.body.classList.remove('modal-open');
                
                // Remove backdrop if it exists
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) {
                    backdrop.remove();
                }
            }
            
            isModalStuck = false;
        } catch (error) {
            console.error('Error hiding break modal:', error);
            forceCloseModal('error');
        }
    }

    function startBreakCountdown() {
        let breakTime = 20;
        const countdownElement = document.getElementById('break-countdown');
        
        if (!countdownElement) {
            console.error('Break countdown element not found');
            return;
        }
        
        // Clear any existing break interval
        if (breakModalTimeout) {
            clearInterval(breakModalTimeout);
        }
        
        breakModalTimeout = setInterval(() => {
            breakTime--;
            if (countdownElement) {
                countdownElement.textContent = breakTime;
            }
            
            if (breakTime <= 0) {
                clearInterval(breakModalTimeout);
                breakModalTimeout = null;
                if (countdownElement) {
                    countdownElement.textContent = 'Done!';
                }
                
                // Auto-complete break after countdown
                setTimeout(() => {
                    if (currentBreak) {
                        completeBreak();
                    } else {
                        // If no break record, just close modal
                        hideBreakModal();
                        resetTimer();
                    }
                }, 2000);
            }
        }, 1000);
    }

    // Enhanced audio notification system
    function playNotificationSound() {
        try {
            // Get user's sound preferences
            const soundType = '{{ settings.notification_sound_type|default:"gentle" }}';
            const soundEnabled = {{ settings.sound_notification|yesno:"true,false" }};
            const soundVolume = {{ settings.sound_volume|default:0.5 }};
            
            if (!soundEnabled) {
                console.log('Sound notifications disabled by user');
                return;
            }
            
            // Play sound based on user preference
            playBreakReminderSound(soundType, soundVolume);
            
        } catch (error) {
            console.error('Error playing notification sound:', error);
            // Fallback to basic beep
            playBasicBeep();
        }
    }
    
    function playBreakReminderSound(soundType = 'gentle', volume = 0.5) {
        const soundOptions = {
            'gentle': {
                frequency: 800,
                duration: 500,
                pattern: [1, 0.5, 1] // On, pause, on
            },
            'chime': {
                frequency: [523, 659, 784], // C, E, G chord
                duration: 300,
                pattern: [1, 1, 1]
            },
            'beep': {
                frequency: 1000,
                duration: 200,
                pattern: [1, 0.3, 1, 0.3, 1]
            },
            'bell': {
                frequency: [440, 554, 659], // A, C#, E
                duration: 800,
                pattern: [1]
            }
        };
        
        const sound = soundOptions[soundType] || soundOptions['gentle'];
        
        // Use Web Audio API for better control
        if (window.AudioContext || window.webkitAudioContext) {
            playWebAudioSound(sound, volume);
        } else {
            // Fallback for older browsers
            playBasicBeep(volume);
        }
    }
    
    function playWebAudioSound(soundConfig, volume = 0.5) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const { frequency, duration, pattern } = soundConfig;
            
            let currentTime = audioContext.currentTime;
            
            pattern.forEach((amplitude, index) => {
                if (amplitude > 0) {
                    // Create oscillator for each tone
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Set frequency (single or array for chords)
                    if (Array.isArray(frequency)) {
                        const freq = frequency[index % frequency.length];
                        oscillator.frequency.setValueAtTime(freq, currentTime);
                    } else {
                        oscillator.frequency.setValueAtTime(frequency, currentTime);
                    }
                    
                    // Configure gain envelope for smooth sound with user volume
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3 * amplitude, currentTime + 0.01);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.1 * amplitude, currentTime + duration/1000 - 0.01);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + duration/1000);
                    
                    // Connect audio nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Start and stop oscillator
                    oscillator.start(currentTime);
                    oscillator.stop(currentTime + duration/1000);
                }
                
                currentTime += duration/1000 + 0.1; // Add small gap between tones
            });
            
            // Show visual feedback
            showSoundNotification('🔔 Break time! Look at something 20 feet away');
            
        } catch (error) {
            console.error('Web Audio API error:', error);
            
            // Browser-specific error handling
            const userAgent = navigator.userAgent;
            if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                console.log('Safari detected, using fallback audio method');
            } else if (userAgent.includes('Firefox')) {
                console.log('Firefox detected, using HTML5 audio fallback');
            } else if (userAgent.includes('Mobile') || userAgent.includes('Android') || userAgent.includes('iPhone')) {
                console.log('Mobile device detected, using simplified audio');
                // Try vibration as additional feedback on mobile
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200]);
                }
            }
            
            playBasicBeep(volume);
        }
    }
    
    function playBasicBeep(volume = 0.5) {
        try {
            // Fallback using HTML5 Audio with generated tone
            const beepSound = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwjBC2OzPLZhzsCFmm98OKicxoNTqXo9KR1FAxNn+Dvwn0pBS19yO7djjoJHmS58OycQQsUYLXr66ZRFQ9Mn+DwxXwpBS5+yO7djjoJHWS58OycQQsUYLXr66ZRFQ==';
            
            const audio = new Audio(beepSound);
            audio.volume = Math.max(0.1, Math.min(1.0, volume)); // Clamp volume between 0.1 and 1.0
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('Break reminder sound played successfully');
                        showSoundNotification('🔔 Break time!');
                    })
                    .catch(error => {
                        console.log('Could not play notification sound:', error.message);
                        // Show visual notification instead
                        showSoundNotification('🔔 BREAK TIME! Look 20 feet away', 'warning');
                    });
            }
            
        } catch (error) {
            console.error('Basic beep error:', error);
            showSoundNotification('🔔 BREAK TIME! Look 20 feet away', 'warning');
        }
    }
    
    function showSoundNotification(message, type = 'info') {
        // Create visual notification when sound plays
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} sound-notification`;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10001;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: soundPulse 2s ease-in-out;
        `;
        notification.innerHTML = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'fadeOut 0.5s ease-out forwards';
            setTimeout(() => notification.remove(), 500);
        }, 3000);
    }
    
    // Test sound function for user preference
    function testNotificationSound(soundType = 'gentle', volume = 0.5) {
        console.log('Testing sound:', soundType, 'at volume:', volume);
        playBreakReminderSound(soundType, volume);
    }
    
    // Request audio permission on first interaction
    function requestAudioPermission() {
        if (window.AudioContext || window.webkitAudioContext) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.log('Audio context initialization failed:', error);
            }
        }
    }
    
    // Modal management helper functions
    function clearModalTimeouts() {
        if (breakModalTimeout) {
            clearInterval(breakModalTimeout);
            breakModalTimeout = null;
        }
        if (modalAutoCloseTimeout) {
            clearTimeout(modalAutoCloseTimeout);
            modalAutoCloseTimeout = null;
        }
    }
    
    function forceCloseModal(reason = 'unknown') {
        console.log('Force closing modal due to:', reason);
        try {
            clearModalTimeouts();
            
            const modalElement = document.getElementById('breakModal');
            if (modalElement) {
                // Force hide modal
                modalElement.style.display = 'none';
                modalElement.classList.remove('show');
                modalElement.setAttribute('aria-hidden', 'true');
            }
            
            // Remove body classes and backdrop
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
            
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            
            // Reset modal state
            isModalStuck = false;
            
            // Show user notification
            showNotification('Break reminder closed. Timer will resume automatically.', 'info');
            
            // Resume timer if session is active
            if (currentSession && !timerInterval) {
                resetTimer();
            }
            
        } catch (error) {
            console.error('Error force closing modal:', error);
            // Last resort: refresh page
            showNotification('Refreshing page to resolve modal issue...', 'warning');
            setTimeout(() => location.reload(), 2000);
        }
    }
    
    function handleModalError() {
        console.error('Modal error detected, attempting recovery');
        isModalStuck = true;
        
        // Try to complete break automatically
        if (currentBreak) {
            completeBreak();
        } else {
            forceCloseModal('error_recovery');
        }
    }
    
    function onModalShown() {
        console.log('Break modal shown successfully');
        // Set focus trap for accessibility
        const modal = document.getElementById('breakModal');
        const firstFocusable = modal.querySelector('button, input');
        if (firstFocusable) {
            firstFocusable.focus();
        }
    }
    
    function onModalHidden() {
        console.log('Break modal hidden successfully');
        clearModalTimeouts();
        isModalStuck = false;
    }
    
    // Emergency escape mechanism
    function addEmergencyEscape() {
        let escapeKeyCount = 0;
        let escapeKeyTimer = null;
        
        document.addEventListener('keydown', function(e) {
            // Double ESC to force close stuck modal
            if (e.key === 'Escape') {
                escapeKeyCount++;
                
                if (escapeKeyTimer) {
                    clearTimeout(escapeKeyTimer);
                }
                
                if (escapeKeyCount >= 2) {
                    const modal = document.getElementById('breakModal');
                    if (modal && modal.classList.contains('show')) {
                        forceCloseModal('double_escape');
                    }
                    escapeKeyCount = 0;
                } else {
                    escapeKeyTimer = setTimeout(() => {
                        escapeKeyCount = 0;
                    }, 1000);
                }
            }
            
            // Ctrl+Alt+R to force refresh if everything is stuck
            if (e.ctrlKey && e.altKey && e.key === 'r') {
                if (isModalStuck) {
                    showNotification('Emergency refresh triggered', 'warning');
                    setTimeout(() => location.reload(), 1000);
                }
            }
        });
    }

    function showNotification(message, type = 'info') {
        try {
            const alertClass = `alert-${type}`;
            const notification = document.createElement('div');
            notification.className = `alert ${alertClass} alert-dismissible fade show notification`;
            notification.style.zIndex = '10000'; // Ensure it appears above modals
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        } catch (error) {
            console.error('Error showing notification:', error);
            // Fallback to console log
            console.log('Notification:', message);
        }
    }

    // Initialize escape mechanisms and audio
    addEmergencyEscape();
    initializeAudioSystem();
    
    // Initialize timer if there's an active session (with better error handling)
    {% if active_session %}
        try {
            // Calculate remaining time based on current interval
            const sessionStartTime = new Date('{{ active_session.start_time|date:"c" }}');
            const now = new Date();
            const elapsedMinutes = Math.floor((now - sessionStartTime) / 60000);
            const intervalsCompleted = {{ active_session.total_intervals_completed }};
            const currentIntervalElapsed = elapsedMinutes - (intervalsCompleted * 20);
            
            console.log('Initializing active session:', {
                elapsedMinutes,
                intervalsCompleted,
                currentIntervalElapsed
            });
            
            if (currentIntervalElapsed < 20 && currentIntervalElapsed >= 0) {
                timeRemaining = (20 - currentIntervalElapsed) * 60;
                if (timeRemaining > 0) {
                    startTimer();
                } else {
                    // Timer should have completed, but add safety check
                    console.log('Timer should have completed, checking server state');
                    syncTimerState();
                }
            } else if (currentIntervalElapsed >= 20) {
                // Timer should have completed, but verify with server first
                console.log('Timer appears completed, syncing with server');
                syncTimerState();
            } else {
                // Negative elapsed time, something's wrong
                console.warn('Negative elapsed time detected, syncing with server');
                syncTimerState();
            }
        } catch (error) {
            console.error('Error initializing timer:', error);
            showNotification('Timer initialization error. Please refresh the page.', 'warning');
        }
    {% endif %}
    
    // Handle page visibility change to maintain timer state (improved)
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'visible') {
            console.log('Page became visible, checking session state');
            
            // Check if modal is stuck
            const modal = document.getElementById('breakModal');
            if (modal && modal.classList.contains('show') && !currentBreak) {
                console.warn('Found stuck modal without active break');
                forceCloseModal('visibility_check');
            }
            
            // Sync timer state if we have an active session
            if (currentSession) {
                // Small delay to ensure page is fully active
                setTimeout(() => {
                    syncTimerState();
                }, 500);
            }
        } else {
            console.log('Page hidden, timer will continue in background');
        }
    });
    
    // Sync timer state with server (improved with error handling)
    function syncTimerState() {
        if (!currentSession) {
            console.log('No active session to sync');
            return;
        }
        
        // Add timeout to prevent hanging requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        fetch('{% url "timer:sync_session" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                session_id: currentSession
            }),
            signal: controller.signal
        })
        .then(response => {
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return response.json();
        })
        .then(data => {
            if (data.success) {
                handleSuccessfulSync(data);
            } else {
                handleSyncError('Server returned error: ' + (data.message || 'Unknown error'));
            }
        })
        .catch(error => {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                console.warn('Timer sync request timed out');
                handleSyncTimeout();
            } else {
                console.error('Error syncing timer state:', error);
                handleSyncError(error.message);
            }
        });
    }
    
    function handleSuccessfulSync(data) {
        try {
            if (data.session_active) {
                // Update current interval
                currentInterval = data.interval_id;
                
                // Recalculate timer based on server state
                const elapsedSeconds = data.interval_elapsed_seconds;
                const intervalDurationSeconds = data.interval_duration_minutes * 60;
                
                if (elapsedSeconds < intervalDurationSeconds) {
                    const newTimeRemaining = intervalDurationSeconds - elapsedSeconds;
                    
                    // Only update if there's a significant difference (more than 5 seconds)
                    if (Math.abs(timeRemaining - newTimeRemaining) > 5) {
                        timeRemaining = newTimeRemaining;
                        updateTimerDisplay();
                        updateProgressRing();
                    }
                    
                    if (!timerInterval) {
                        startTimer();
                    }
                } else {
                    // Timer should have completed
                    console.log('Timer completed while away, showing break modal');
                    onTimerComplete();
                }
            } else {
                // Session ended on server side
                console.log('Session ended on server, cleaning up');
                stopTimer();
                currentSession = null;
                currentInterval = null;
                showNotification('Your session has ended', 'info');
                
                // Delayed reload to allow user to see notification
                setTimeout(() => location.reload(), 2000);
            }
        } catch (error) {
            console.error('Error handling sync response:', error);
            handleSyncError('Failed to process sync response');
        }
    }
    
    function handleSyncError(errorMessage) {
        console.warn('Timer sync failed:', errorMessage);
        
        // Don't show error to user for minor sync issues
        // Just continue with client-side timer
        if (!timerInterval && currentSession) {
            console.log('Restarting timer due to sync failure');
            startTimer();
        }
    }
    
    function handleSyncTimeout() {
        console.warn('Timer sync timed out, continuing with local timer');
        // Continue with local timer state
        if (!timerInterval && currentSession) {
            startTimer();
        }
    }
    
    // Real-time updates for personal statistics only
    function updateDashboardStats() {
        fetch('{% url "analytics:dashboard_metrics_api" %}')
            .then(response => response.json())
            .then(data => {
                // Update today's personal stats dynamically
                const todayStats = data.today;
                
                // Find and update stat cards by their structure
                const statCards = document.querySelectorAll('.card-body h3');
                statCards.forEach(element => {
                    const parentCard = element.closest('.card-body');
                    const label = parentCard.querySelector('p');
                    
                    if (label && label.textContent.includes('Minutes Worked')) {
                        element.textContent = todayStats.work_minutes;
                    } else if (label && label.textContent.includes('Intervals Completed')) {
                        element.textContent = todayStats.intervals_completed;
                    } else if (label && label.textContent.includes('Breaks Taken')) {
                        element.textContent = todayStats.breaks_taken;
                    } else if (label && label.textContent.includes('Compliance Rate')) {
                        element.textContent = todayStats.compliance_rate.toFixed(0) + '%';
                    }
                });
            })
            .catch(error => console.error('Error updating dashboard stats:', error));
    }
    
    // Track activity when user interacts
    function trackDashboardActivity(eventType, eventData = {}) {
        fetch('{% url "analytics:track_activity" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                event_type: eventType,
                event_data: eventData
            })
        }).catch(error => {
            console.error('Error tracking activity:', error);
        });
    }
    
    // Update stats every 30 seconds and track page view
    setInterval(updateDashboardStats, 30000);
    trackDashboardActivity('feature_used', { feature: 'dashboard' });
    
    // Test function for modal fixes (development/debug)
    window.testModalFixes = function() {
        console.log('🔧 Testing modal fixes...');
        
        const tests = [
            {
                name: 'Emergency escape mechanism',
                test: () => typeof addEmergencyEscape === 'function' ? 'Available' : 'Missing'
            },
            {
                name: 'Force close function',
                test: () => typeof forceCloseModal === 'function' ? 'Available' : 'Missing'
            },
            {
                name: 'Modal timeout variables',
                test: () => (modalAutoCloseTimeout !== undefined && breakModalTimeout !== undefined) ? 'Available' : 'Missing'
            },
            {
                name: 'Error handling functions',
                test: () => (typeof handleSyncError === 'function' && typeof handleModalError === 'function') ? 'Available' : 'Missing'
            }
        ];
        
        tests.forEach(test => {
            try {
                const result = test.test();
                console.log(`${result === 'Available' ? '✅' : '❌'} ${test.name}: ${result}`);
            } catch (error) {
                console.log(`❌ ${test.name}: Error - ${error.message}`);
            }
        });
        
        return 'Modal fix tests completed - check console for results';
    };
    
    // Add audio test functions to window
    window.testBreakSound = function(type = 'gentle') {
        const volume = {{ settings.sound_volume|default:0.5 }};
        testNotificationSound(type, volume);
        return 'Testing sound: ' + type + ' at volume: ' + (volume * 100) + '%';
    };
    window.checkAudioSupport = checkAudioSupport;
    
    // Log that fixes are loaded
    console.log('✅ Timer modal fixes loaded successfully');
    console.log('💡 Use window.testModalFixes() to test emergency mechanisms');
    console.log('🔊 Use window.testBreakSound("gentle"|"chime"|"beep"|"bell") to test sounds');
    console.log('🔧 Emergency shortcuts: Double ESC to force close modal, Ctrl+Alt+R to refresh if stuck');
    
    // Audio system initialization and browser compatibility
    function initializeAudioSystem() {
        // Check audio support on page load
        const support = checkAudioSupport();
        
        if (!support.webAudio && !support.htmlAudio) {
            console.warn('No audio support detected');
            showNotification('Audio notifications not supported in this browser', 'warning');
        } else if (!support.webAudio) {
            console.info('Using HTML5 Audio fallback (limited sound options)');
        }
        
        // Request audio permission early (Chrome requires user gesture)
        document.addEventListener('click', requestAudioPermission, { once: true });
        document.addEventListener('touchstart', requestAudioPermission, { once: true });
    }
    
    function checkAudioSupport() {
        const support = {
            webAudio: !!(window.AudioContext || window.webkitAudioContext),
            htmlAudio: !!window.Audio,
            notifications: 'Notification' in window,
            vibration: 'vibrate' in navigator,
            userAgent: navigator.userAgent
        };
        
        // Browser-specific checks
        support.browser = {
            chrome: /Chrome/.test(navigator.userAgent),
            firefox: /Firefox/.test(navigator.userAgent),
            safari: /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
            edge: /Edg/.test(navigator.userAgent),
            mobile: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent)
        };
        
        console.log('🔊 Audio support check:', support);
        return support;
    }
</script>
{% endblock %}